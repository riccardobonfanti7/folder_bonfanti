{"TPI/CLI":{"title":"CLI","links":["TPI/LINUX"],"tags":[],"content":"Introduzione alla Command Line Interface (CLI)\nCLI è un tipo di interfaccia utente caratterizzata da un’interazione testuale tra utente ed elaboratore.\nL’utente impartisce comandi testuali in input mediante tastiera alfanumerica e riceve risposte testuali in output dall’elaboratore mediante display o stampante alfanumerici. Nei sistemi operativi moderni usati nei personal computer, al posto della CLI, in buona parte, c’è l’interfaccia grafica (GUI).\n\nPuoi trovare un elenco di comandi essenziali nel file LINUX.\n\nRisorse Aggiuntive\nPer approfondire ulteriormente, puoi visitare la documentazione ufficiale di Linux su linux.org."},"TPI/CODICE-RILOCABILE":{"title":"CODICE RILOCABILE","links":[],"tags":[],"content":"==Un codice rilocabile è un tipo di codice generato durante la fase di compilazione di un programma==, in cui gli indirizzi delle istruzioni e dei dati non sono definitivi, ma relativi. Ciò significa che, invece di fare riferimento a indirizzi di memoria fissi (assoluti), il codice utilizza indirizzi logici o simbolici che verranno successivamente trasformati in indirizzi fisici durante il caricamento del programma in memoria.\nQuando un programma contenente codice rilocabile viene caricato in memoria, il loader del sistema operativo esegue una rilocazione, cioè modifica gli indirizzi relativi per adattarli alla posizione effettiva del programma in memoria. Questo permette al programma di essere caricato in diverse posizioni fisiche della memoria, rendendolo più flessibile e facilitando la gestione della memoria nei sistemi operativi multitasking.\nIl compilatore genera gli indirizzi ipotizzando che il programma venga caricato nella memoria a partire dalla cella 0 e in base a questo valore vengono generati tutti gli indirizzi e i collegamenti dati/istruzioni. Può avvenire in momenti diversi:\n\nAll’atto del caricamento in memoria (rilocazione statica): viene individuato l’indirizzo iniziale (indirizzo base) e viene sommato a tutti i riferimenti presenti nel programma (offset).\nIn fase di esecuzione del programma (rilocazione dinamica): viene inserito in apposito registro (registro base) il valore dell’indirizzo effettivo della prima locazione di memoria centrale; quindi durante l’esecuzione, istruzione per istruzione, si calcola l’indirizzo fisico sommando a ogni indirizzo relativo il contenuto del registro base.\n\nMMU (Memory Management Unit)\nLa MMU è un dispositivo hardware che prende ogni indirizzo logico generato da un processo e lo riloca, trasformandolo in un indirizzo fisico utilizzabile direttamente dalla memoria fisica del sistema. Questa operazione è basata su un valore contenuto in un registro di rilocazione (chiamato anche registro base). Tale registro contiene l’indirizzo di inizio della porzione di memoria fisica assegnata al processo.\nFormula di rilocazione\nPer eseguire la conversione tra indirizzi logici e fisici, la MMU utilizza la seguente formula:\n\nIndirizzo fisico=Indirizzo logico+Indirizzo di rilocazione\n\n\nIndirizzo logico: l’indirizzo generato dal programma o dal processo in esecuzione. Questo indirizzo è relativo alla memoria del processo.\nIndirizzo di rilocazione: il valore nel registro di rilocazione (registro base) che indica l’inizio dell’area di memoria fisica assegnata al processo.\nIndirizzo fisico: l’indirizzo reale in memoria fisica a cui si accede.\n\nLinking dei programmi: esegue il calcolo degli indirizzi logici\nBinding: passaggio da indirizzo logico a fisico , può essere fatta in momenti diversi:\n\nDurante l’esecuzione: MMU dispositivo hardware che attua il mapping/ mappatura( associazione tra ind logico e fisico): processo in esecuzione genera solo ind logici tradotti dalla MMU in corrispondenti indirizzi fisici.(rilocazione dinamica)\nnel momento del loading del programma (rilocazione statica)\ndurante la compilazione (indirizzamento assoluto)\n"},"TPI/Compilatore":{"title":"Compilatore","links":["TPI/SO"],"tags":[],"content":"Cos’è un Compilatore?\nUn compilatore è un programma che traduce il codice sorgente scritto in un linguaggio di programmazione in un formato eseguibile, generalmente codice macchina. Questo processo di traduzione consente al computer di eseguire le istruzioni scritte dall’utente.\nFunzionamento\nIl processo di compilazione può essere suddiviso in diverse fasi:\n\n\nAnalisi lessicale: Il compilatore legge il codice sorgente e lo divide in unità lessicali, chiamate “token”. Ogni token rappresenta un elemento del linguaggio, come parole chiave, identificatori, operatori e simboli.\n\n\nAnalisi sintattica: Il compilatore verifica la sintassi del codice per assicurarsi che segua le regole grammaticali del linguaggio.\n\n\nAnalisi semantica: Qui, il compilatore controlla il significato del codice, assicurandosi che le operazioni siano appropriate.\n\n\nGenerazione del codice: Infine, il compilatore genera il codice macchina o un file eseguibile che il computer può eseguire direttamente.\n\n\nVantaggi\n1. Velocità di Esecuzione\nIl codice compilato tende a essere più veloce rispetto a quello interpretato, poiché è già stato tradotto in istruzioni di codice macchina.\n2. Controllo degli Errori\nDurante la fase di compilazione, il compilatore rileva e segnala errori di sintassi e semantica prima che il programma venga eseguito, riducendo la probabilità di errori a runtime.\nSvantaggi\n1. Tempo di Compilazione\nLa fase di compilazione può richiedere tempo, specialmente per programmi di grandi dimensioni. Ogni modifica al codice richiede una nuova compilazione.\n2. Debugging Complesso\nGli errori potrebbero non essere evidenti fino a quando il programma non viene eseguito. La ricerca di errori può richiedere più tempo rispetto a un interprete, che fornisce feedback immediato.\n3. Dipendenza dalla Piattaforma\nIl codice compilato è specifico per una piattaforma. Un programma compilato per Windows, ad esempio, potrebbe non funzionare su un SO linux senza una nuova compilazione."},"TPI/INTERPRETE":{"title":"INTERPRETE","links":["TPI/Compilatore"],"tags":[],"content":"Cos’è un interprete?\n\nUn interprete è un tipo di programma software che esegue il codice sorgente scritto in un linguaggio di programmazione, riga per riga. Questo approccio consente agli sviluppatori di ottenere feedback immediato e facilita il processo di debugging.\n\nFunzionamento\nIl funzionamento di un interprete può essere suddiviso in diverse fasi:\n\n\nAnalisi lessicale: L’interprete esamina il codice sorgente e lo scompone in unità lessicali chiamate token. Ogni token rappresenta un elemento del linguaggio, come una parola chiave, un identificatore o un simbolo.\n\n\nAnalisi sintattica: Dopo la fase di analisi lessicale, l’interprete verifica se i token formano una sintassi valida secondo le regole del linguaggio.\n\n\nEsecuzione: Una volta che il codice è stato analizzato e convalidato, l’interprete esegue le istruzioni in tempo reale. Ogni riga di codice viene tradotta e eseguita immediatamente.\n\n\nGestione degli errori: Se l’interprete incontra un errore durante l’esecuzione, si ferma e fornisce un messaggio di errore, consentendo all’utente di correggere il problema.\n\n\nVantaggi\n1. Esecuzione immediata\nUno dei principali vantaggi di un interprete è la possibilità di vedere i risultati immediatamente. Gli sviluppatori possono eseguire parti del codice senza dover compilare l’intero programma.\n2. Facilità di debugging\nIl debugging è semplificato, poiché l’interprete esegue il codice riga per riga. Gli sviluppatori possono identificare rapidamente la riga problematica e apportare modifiche al volo.\n3. Portabilità\nI linguaggi interpretati tendono ad essere più portabili. Poiché il codice sorgente viene eseguito da un interprete specifico per ogni piattaforma, è possibile eseguire lo stesso codice su diverse piattaforme senza modifiche significative.\nSvantaggi\n1. Velocità di esecuzione\nI programmi eseguiti tramite un interprete possono essere più lenti rispetto a quelli compilati. Questo è dovuto al fatto che l’interprete deve tradurre il codice riga per riga.\n2. Dipendenza dal codice sorgente\nPer eseguire un programma, è necessario avere accesso al codice sorgente. Ciò può rendere difficile la distribuzione di software chiuso o commerciale, poiché gli utenti devono avere accesso al codice.\nInterprete vs Compilatore\nÈ importante notare la differenza tra interpreti e compilatori. Mentre gli interpreti eseguono il codice riga per riga, i compilatori traducono l’intero codice sorgente in un file eseguibile prima dell’esecuzione. Questo porta a differenze significative in termini di prestazioni e usabilità.\n\nEsecuzione: Gli interpreti sono più adatti per il testing e lo sviluppo, mentre i compilatori sono preferiti per applicazioni ad alte prestazioni.\nFeedback: Gli interpreti forniscono un feedback immediato, mentre i compilatori richiedono una fase di compilazione prima di poter eseguire il programma.\n"},"TPI/LINUX":{"title":"LINUX","links":["TPI/SO","TPI/CLI","TPI/metadati"],"tags":[],"content":"GUIDA COMANDI\n\nLa shell più comunemente utilizzata per i SO Linux è chiamata shell Bash(CLI).\n\nIl ~ simbolo viene utilizzato come abbreviazione per la directory home dell’utente. \nIn questa guida potrai trovare i comandi fondamentali di Linux con i relativi esempi e spiegazioni di ciò che avviene.\ncomando [opzioni] [argomenti]\n\npwd [OPTIONS]\nIl comando pwd stampa la directory di lavoro, che è la posizione corrente dell’utente all’interno del filesystem.\n\nsysadmin@localhost:~$ pwd\n\n/home/sysadmin\n\n\n\ncd [options] [path]\nPer navigare nel filesystem, usa cd command.\n\nsysadmin@localhost:~$ cd Documents\n\nsysadmin@localhost:~/Documents$\n\n\nIl carattere ~ è equivalente a /home/sysadmin, che rappresenta la directory home dell’utente.\nSe utilizzato senza argomenti, il comando cd porterà l’utente alla propria directory home.\n\nsysadmin@localhost:~/Documents$ cd\n\nsysadmin@localhost:~$\n\n\nPuoi mettere anche un percorso di tipo assoluto utilizzando il comando cd:\n\nsysadmin@localhost:~/Documents$ cd /home/sysadmin/Documents/School/Art\n\nsysadmin@localhost:~/Documents/School/Art$\n\n\nDue caratteri punto .. rappresentano sempre una directory più in alto rispetto alla directory corrente.\n\nsysadmin@localhost:~/Documents/School/Art$ cd ..\n\nsysadmin@localhost:~/Documents/School$\n\n\n\nls [OPTION]… [FILE]…\nQuesto comando ls viene utilizzato per visualizzare il contenuto di una directory e può fornire informazioni dettagliate sui file.\n\nsysadmin@localhost:~$ ls\n\nDesktop Documents Downloads Music Pictures Public\n\n\nIl comando ls può essere utilizzato anche per elencare il contenuto di qualsiasi directory nel filesystem. Fornire il percorso della directory come argomento:\n\nsysadmin@localhost:~$ ls /var\n\nbackups cache lib local lock log mail opt run spool tmp\n\n\nIl comando ls omette i file nascosti per impostazione predefinita. Un file nascosto è qualsiasi file (o directory) che inizia con un punto(.) carattere.\n\nsysadmin@localhost:~$ ls -a\n\n. .bashrc .selected_editor Downloads Public\n\n.. .cache Desktop Music Templates\n\n.bash_logout .profile Documents Pictures Videos\n\n\nA ogni file sono associati dettagli chiamati metadati.\nPer visualizzare queste informazioni, utilizzare ** l’opzione -l** del comando ls.\n\nsysadmin@localhost:~$ ls -l /var/log/\n\ntotal 900\n\n-rw-r--r-- 1 root root 15322 Dec 10 21:33 alternatives.log\n\ndrwxr-xr-x 1 root root 4096 Jul 19 06:52 apt\n\n-rw-r----- 1 syslog adm 371 Dec 15 16:38 auth.log\n\n-rw-r--r-- 1 root root 35330 May 26 2018 bootstrap.log\n\n-rw-rw---- 1 root utmp 0 May 26 2018 btmp\n\n-rw-r----- 1 syslog adm 197 Dec 15 16:38 cron.log\n\n-rw-r--r-- 1 root adm 85083 Dec 10 21:33 dmesg\n\n-rw-r--r-- 1 root root 351960 Jul 19 06:52 dpkg.log\n\n-rw-r--r-- 1 root root 32064 Dec 10 21:33 faillog\n\ndrwxr-xr-x 2 root root 4096 Jul 19 06:51 journal\n\n-rw-rw-r-- 1 root utmp 292584 Dec 15 16:38 lastlog\n\n-rw-r----- 1 syslog adm 14185 Dec 15 16:38 syslog\n\n-rw------- 1 root root 64128 Dec 10 21:33 tallylog\n\n-rw-rw-r-- 1 root utmp 384 Dec 15 16:38 wtmp\n\n\n\nsysadmin@localhost:~$ ls -ld\n\ndrwxr-xr-x 1 sysadmin sysadmin 224 Nov 7 17:07 .\n\n\n\nPer eseguire un elenco ricorsivo, utilizzare l’opzione -R del comando ls:\n\nsysadmin@localhost:~$ ls -R /etc/ppp\n\n/etc/ppp:\n\nip-down.d ip-up.d\n\n  \n\n/etc/ppp/ip-down.d:\n\nbind9\n\n  \n\n/etc/ppp/ip-up.d:\n\nbind9\n\n\n\nPer ordinare i file in base alla dimensione, possiamo utilizzare l’opzione -S.\n\nsysadmin@localhost:~$ ls -S /etc/ssh\n\nmoduli ssh_host_ed25519_key ssh_host_ecdsa_key.pub\n\nsshd_config ssh_host_rsa_key.pub ssh_host_ed25519_key.pub\n\nssh_host_rsa_key ssh_import_id\n\nssh_config ssh_host_ecdsa_key\n\n\nPotrebbe anche essere utile utilizzare l’opzione -h per visualizzare le dimensioni dei file leggibili dall’uomo.\nL’opzione -t ordina i file in base all’ora in cui sono stati modificati."},"TPI/Memoria-virtuale":{"title":"Memoria virtuale","links":[],"tags":[],"content":"La memoria virtuale è una tecnica che permette al computer di usare una parte del disco rigido come estensione della RAM. Quando la RAM è piena, il sistema operativo sposta temporaneamente su disco alcuni dati o processi inattivi (swap out) per fare spazio in RAM per altri programmi attivi. Questo consente di eseguire programmi più grandi della memoria fisica disponibile, dando l’impressione di avere più RAM di quella realmente installata.\nProgram counter cambia:\nIl program counter (PC) è un registro che tiene traccia dell’istruzione successiva da eseguire. Quando avviene uno swap out in memoria virtuale, cioè lo spostamento temporaneo di un processo inattivo sul disco, il sistema deve aggiornare il program counter per ricordare a che punto si trovava l’esecuzione di quel processo.\nQuando il processo viene riportato in RAM per continuare l’esecuzione, il program counter viene ripristinato al valore corretto, consentendo al processo di riprendere dall’istruzione esatta in cui era stato interrotto. Questo aggiornamento è essenziale per mantenere la coerenza dell’esecuzione del programma."},"TPI/PROGRAMMA-e-PROCESSO":{"title":"PROGRAMMA e PROCESSO","links":["TPI/INTERPRETE","TPI/Compilatore","TPI/Tecniche-di-gestione-della-memoria"],"tags":[],"content":"Definizioni\nIn parole semplici, un programma per computer è una serie di istruzioni dettagliate che indicano al computer cosa fare.\n==Un programma è costituito dall’insieme delle sue istruzioni memorizzate su una memoria di massa. È una entità statica.==\nPer essere eseguito, un programma deve essere interpretato o compilato. Gli interpreti eseguono il codice riga per riga, mentre i compilatori trasformano tutto il codice in un formato eseguibile in una singola operazione.\n==Processo è un’istanza di un programma in evoluzione, è una entità dinamica utilizza risorse come CPU, memoria e file aperti.\nUn Processo possiede una traccia di esecuzione==(sequenza di stati assunti dal processore durante l’esecuzione del processo).\nA un processo sono associati:\n\n==Codice eseguibile==\nSpazio di memoria con i ==dati== e lo spazio per lo Stack\n==Il PCB(process control Block) o descrittore di processo: struttura apposita che contiene informazioni dello stato del processo,== come: ==PID== ( valore numeri da 1 a 30000) pid =0 indica un processo speciale chiamato swapper, PID =1  appartiene al processo INIT( primo processo creato all’avvio del sistema e rimane in funzione tutto il tempo); ==puntatore==(indirizzo del descrittore del processo che l’ha generato(processo padre)), la priorità, ==stato di avanzamento(contenuto dei registri di lavoro), immagine della memoria==, info relative alle ==altre risorse assegnate al processo==.\n\nProcesso chiamato padre può generare copie di se stesso chiamate processi figli.\n\nProcesso per essere eseguito deve essere allocato in memoria centrale (RAM).\nDeve risiedere in una area di RAM sufficientemente grande e contigua\n\nQui puoi trovare le varie Tecniche di gestione della memoria.\nUn processo può essere rimosso dalla memoria e trasferito su disco(swap out) per permettere l’esecuzione di un altro processo che richiede più memoria RAM e in seguito riportarlo in memoria (swap in) per proseguire l’esecuzione.\n\nLo scambio di contesto (contex-switching) avviene quando il sistema operativo interrompe l’esecuzione di un processo (per esempio, per dare spazio a un altro processo) e salva lo stato del processo corrente per poterlo riprendere in un momento successivo e così la CPU passa ad eseguire un altro processo.\n\nSwap Out\n\n\nObiettivo: L’operazione di swap out viene eseguita quando la RAM non ha spazio sufficiente per ospitare tutti i processi attivi. Questo può accadere quando:\n\n\nUn processo in esecuzione richiede più memoria di quanto attualmente disponibile.\n\n\nUn processo (o parte di esso) viene trasferito dallo spazio di memoria RAM allo spazio di swap su disco rigido(hard disk).\n\n\nQuesto libera spazio in RAM, consentendo ad altri processi di essere caricati o continuare la loro esecuzione.\n\n\nSwap In\n\nObiettivo: L’operazione di swap in avviene quando il sistema ha bisogno di accedere nuovamente a un processo che è stato precedentemente swappato nel disco rigido.\nIl sistema operativo recupera il processo dallo spazio di swap su disco e lo carica di nuovo in RAM.\nSe non c’è abbastanza spazio libero in RAM, potrebbe essere necessario swappare un altro processo attualmente in esecuzione per fare spazio per quello che si sta caricando.\n"},"TPI/SO":{"title":"SO","links":[],"tags":[],"content":"Cos’è un Sistema Operativo?\nUn sistema operativo (SO) è un software fondamentale che gestisce le risorse hardware e software di un computer. Funziona come intermediario tra l’utente e l’hardware, consentendo l’esecuzione di programmi e la gestione delle risorse del sistema.\n==Sistemi operativi lavorano in multiprogrammazione==. La multiprogrammazione è una tecnica che permette a un sistema operativo di gestire più programmi in memoria contemporaneamente. In questo modo, quando un processo è in attesa, il sistema operativo può passare a un altro processo che è pronto per essere eseguito. Questo approccio consente di ridurre i tempi di inattività e di migliorare l’utilizzo della CPU.\nFunzioni Principali di un Sistema Operativo\n\n\nGestione delle Risorse Hardware: Il SO controlla e coordina l’uso di CPU, memoria, dischi rigidi e dispositivi di input/output.\n\n\nEsecuzione dei Processi: Gestisce l’esecuzione dei programmi, allocando tempo di CPU e memoria in modo efficiente.\n\n\nGestione della Memoria: Tiene traccia della memoria utilizzata dai processi e gestisce la memoria virtuale.\n\n\nGestione dei File: Fornisce un sistema di file per l’organizzazione, la memorizzazione e l’accesso ai dati.\n\n\nInterfaccia Utente: Fornisce un’interfaccia (grafica o testuale) per consentire agli utenti di interagire con il computer.\n\n\nSistemi Operativi Monoutente e Multiutente\n\nMonoutente: Gestisce un solo utente alla volta (es. MS-DOS).\nMultiutente: Permette a più utenti di utilizzare il sistema contemporaneamente.\n\nSistemi mono-processore e multi-processore\nNel sistema mono-processore c’è un unico processore che può eseguire una sola istruzione alla volta. Tuttavia, per simulare il multitasking, il sistema operativo esegue un’alternanza tra i processi, tramite una tecnica chiamata time slicing.\nOgni processo viene eseguito per una piccola quantità di tempo, chiamata quantum di tempo, prima che il processore passi al processo successivo. Anche se i processi avanzano uno alla volta, l’alternanza è così rapida che l’utente percepisce un’esecuzione simultanea.\nNel sistema multi-processore sono presenti più processori fisici o core che possono eseguire i processi realmente in parallelo. Questo significa che diversi processi o thread possono essere assegnati a processori separati e eseguiti simultaneamente.\nQuesta capacità di eseguire processi parallelamente aumenta la potenza di calcolo e consente un multitasking reale, particolarmente utile per carichi di lavoro intensivi o complessi.\nEsempi di Sistemi Operativi\n\nWindows: Un sistema operativo sviluppato da Microsoft, popolare per computer desktop e laptop.\nmacOS: Sistema operativo sviluppato da Apple per i suoi computer.\nLinux: Un sistema operativo open-source molto usato in server.\nAndroid: Basato su Linux, progettato per dispositivi mobili.\n\nVantaggi dei Sistemi Operativi\n\nFacilità d’uso: Offrono interfacce intuitive per l’interazione con l’hardware.\nGestione Efficiente delle Risorse: Ottimizzano l’uso della CPU, della memoria e delle periferiche.\nSicurezza: Forniscono meccanismi per la protezione dei dati e l’autenticazione degli utenti.\n\nDifetti dei Sistemi Operativi\n\nCosti: Alcuni sistemi operativi commerciali possono avere costi elevati di licenza.\nRisorse: I sistemi operativi più complessi richiedono più risorse hardware.\nVulnerabilità: Possono essere soggetti a malware e attacchi informatici se non gestiti correttamente.\n"},"TPI/Tecniche-di-gestione-della-memoria":{"title":"Tecniche di gestione della memoria","links":["TPI/Tecniche-di-gestione-della-memoria","TPI/PROGRAMMA-e-PROCESSO"],"tags":[],"content":"Tecniche di Gestione della Memoria\nLe tecniche di gestione della memoria sono metodi utilizzati dai sistemi operativi per gestire l’allocazione dei processi e l’uso della memoria RAM in modo efficiente. In questa sezione vedremo le principali tecniche: partizionamento fisso, partizionamento variabile, paginazione ,segmentazione e paginazione con segmentazione.\n1. Partizionamento Fisso\nIl Partizionamento fisso è un metodo di gestione della memoria in cui la memoria principale viene suddivisa in blocchi di dimensioni fisse, chiamati “partizioni”. Ogni programma o processo viene allocato in una partizione, e non può superare le dimensioni della partizione stessa.\nPer ogni partizione viene gestita una coda di entrata dei processi in attesa e vengono aggiunti alla coda della partizione più piccola in cui possono essere allocati.\nProblemi:\n\nFrammentazione esterna\nFrammentazione interna\n\n1.Si verifica quando, nonostante la somma totale della memoria libera sia sufficiente per caricare un nuovo processo, questa memoria è sparsa in piccoli blocchi tra le partizioni occupate, quindi non c’è un blocco contiguo abbastanza grande per il nuovo processo.\n2.La frammentazione interna avviene quando la dimensione di un processo è inferiore alla dimensione della partizione in cui viene caricato, lasciando uno spazio non utilizzato all’interno della partizione stessa. Le partizioni sono fisse, non possono essere ridimensionate per adattarsi al processo, e la memoria non utilizzata non può essere riallocata ad altri processi.\n2. Partizionamento Variabile\nIl partizionamento variabile è un altro metodo in cui la memoria viene suddivisa in partizioni di dimensioni variabili, assegnate dinamicamente in base alla dimensione del processo. Ogni partizione si adatta alla dimensione del processo. Non avviene frammentazione interna.\nStrategie di allocazione dinamica della memoria centrale:\n\nFirst-fit: il gestore della memoria scandisce la tabella delle partizioni finché trova la prima zona libera abbastanza grande per contenere il processo. Metodo più veloce\nBest-fit: il gestore della memoria scandisce tutta la tabella delle partizioni e sceglie la zona libera più piccola sufficientemente grande da contenere il processo. Metodo più lento del first-fit e tende a lasciare zone di memoria troppo piccole per essere usate.\nWorst-fit: sceglie la zona libera più grande\nNext-fit: cerca il primo spazio libero in grado di accogliere il processo partendo dallo spaziolibero successivo all’ultimo processo allocato. Questo evita di allocare i processi tutti all’inizio della RAM.\n\n3. Paginazione\nLa paginazione è una tecnica che suddivide la memoria in blocchi di dimensione fissa chiamati pagine fisiche o frame . Ogni processo viene suddiviso in pagine logiche di dimensione fissa, e queste pagine possono essere allocate in qualsiasi posizione nella memoria fisica.\nIl numero di pagine logiche può differire dal numero di pagine fisiche.\n\nSe il numero di pagine logiche è minore delnumero di pagine fisiche il programma potrebbe essere caricato tutto in memoria\nSe la pagine logiche sono di più di quelle fisiche il programma viene caricato parzialmente.\n\nNella paginazione sono presenti due tabelle:\n\ntabella delle pagine fisiche\ntabella delle pagine logiche\n\n1.Formata da tante righe quanti sono i frame in RAM e ogni voce della tabella contiene:\n\nIndirizzi fisici iniziali dei frame: Ogni pagina logica è mappata a un frame fisico specifico in memoria.\nStato della pagina: Indica se una pagina fisica è libera o occupata.(bit di validità)\nID del processo: Identifica quale processo ha caricato una determinata pagina fisica.\n\n2.formata da tante righe quante sono le pagine logiche di un processo e ogni voce della tabella contiene:\n\nBit di validità: Indica se una pagina logica del processo è attualmente in RAM (1) o su disco (0).\nNumero del frame: indica in quale frame quella pagina logica è stata caricata.\n\nTraduzione da indirizzi logici a fisici\nIl dispositivo che si occupa di questa traduzione è la MMU.\n==Indirizzo logico ==è composto da:\n\n==Numero di pagina logica==: identifica quale pagina logica del processo si sta cercando.\n==Offset==: specifica la posizione all’interno della pagina.\n\n==Indirizzo fisico:\n• Indirizzo fisico = Numero del frame fisico + Offset==\n\n==Traduzione tramite la tabella delle pagine:==\n\n\nLa MMU consulta la tabella delle pagine logiche associata al processo attivo.\nCerca la voce corrispondente al numero di pagina logica utilizzato come indice .\nOgni voce della tabella:\nLa voce contiene:\n==Numero del frame fisico==: specifica in quale frame della memoria fisica si trova la pagina logica.\n==Bit di validità==: indica se la pagina è caricata in memoria fisica (1 = valida; 0 = non valida).\n\n\n==Verifica del bit di validità:==\n\n\nSe il bit è 1, la MMU memorizza il numero del frame fisico cercandolo nella tabella delle pagine fisiche e prende l’indirizzo fisico del frame corrispondente con l’offset per generare l’indirizzo fisico finale.\n==Se il bit è 0, si verifica== un page fault, e il SO interviene per caricare la pagina nella memoria fisica\n\nPage fault\nSe durante la traduzione la MMU scopre che il bit di validità di una pagina logica è 0 (la pagina non è in RAM), si verifica un page fault. Questo evento indica che la pagina richiesta si trova su disco e non in memoria fisica.\nAzioni in caso di page fault:\n\nIl sistema operativo sospende l’esecuzione del processo.\nCarica la pagina mancante dal disco in un frame libero della RAM (se non ci sono frame liberi, viene eseguito uno swap-out della pagina logica inattiva in ram per lasciare un frame libero alla pagina logica necessaria in quel momento, da essere caricata.\nAggiorna la tabella delle pagine.\nRiprende l’esecuzione del processo.\n\n4. Segmentazione\nLa segmentazione è una tecnica che divide la memoria in segmenti fisici di dimensioni variabili, dove ogni segmento rappresenta una porzione logica di un programma( suddiviso in segmenti logici ad esempio, codice, dati, stack).Questa suddivisione in prozioni logiche del programma viene fatta dal programmatore. Ogni segmento ha una dimensione variabile e può essere caricato in qualsiasi parte della memoria fisica.\nLa segmentazione utilizza una sola tabella:\nTabella dei segmenti:\n\n==Indirizzo Base==: l’indirizzo di inizio del segmento fisico nella memoria fisica.\n==Limite==: la lunghezza del segmento.\nSe un processo ha N segmenti, la tabella dei segmenti avrà N righe.\n\nTraduzione dell’indirizzo logico a fisico\n\nIndirizzo logico: È composto da due parti:\n\n\n==Numero del segmento==: Indica a quale segmento del programma si sta accedendo.\n==Offset==: È la posizione all’interno di quel segmento.\n\n\nTraduzione da indirizzo logico a fisico  fatta dalla MMU:\n\n\nIl numero del segmento è usato come indice per consultare la tabella dei segmenti.\nLa tabella dei segmenti fornisce l’indirizzo di base del segmentto fisico e il limite.\nSe l’offset è compreso all’interno del limite del segmento (cioè non oltre il fine del segmento), si calcola l’indirizzo fisico come: ==Indirizzo fisico finale =  Base del segmento fisico + offset ==.\nSe l’offset è fuori dal limite, si verifica un segmentazione fault, ovvero il programma sta cercando di accedere a memoria che non è parte del segmento.\n\n5. Paginazione con Segmentazione\nLa paginazione con segmentazione combina i vantaggi della paginazione e della segmentazione. In questo approccio, la memoria centrale fisica è divisa in pagine fisiche (frame) di dimensione fissa, il processo è suddiviso in segmenti logici di dimensioni diverse, ciascuno suddiviso in pagine logiche. I frame hanno la stessa dimensione delle pagine logiche, che infatti vengono caricate in essi.\nIn questo sistema, ci sono due tabelle principali per la gestione della memoria:\n\nTabella dei segmenti:\n\n\n\nOgni processo ha una tabella dei segmenti.\n\n\nOgni voce della tabella dei segmenti corrisponde a un segmento del processo (ad esempio, codice, dati, stack, ecc.).\n\n\nOgni voce nella tabella dei segmenti contiene:\n\n\nBase: l’indirizzo di base del segmento nella memoria fisica.\n\n\nLimite: la dimensione del segmento.\n\n\n\nTabella delle pagine (per ogni segmento):\n\n\nOgni segmento del processo può essere ulteriormente suddiviso in pagine.\nOgni segmento ha la sua tabella delle pagine, che mappa le pagine del segmento ai frame fisici.\nOgni voce nella tabella delle pagine contiene l’indirizzo del frame fisico che corrisponde a una pagina logica.\n\nTraduzione da indirizzo logico a fisico (MMU)\nUn indirizzo logico è composto da tre parti:\n\nIndice del segmento: identifica quale segmento del processo stiamo cercando.\nIndice della pagina all’interno del segmento: identifica quale pagina dentro quel segmento stiamo cercando.\nOffset: la posizione all’interno della pagina.\n\nTraduzione:\n\n\nPassaggio 1 - Traduzione del segmento:\n\n\nIl sistema operativo mantiene una tabella dei segmenti che mappa ogni segmento logico al corrispondente segmento in memoria fisica (indicato da un indirizzo base e un limite).\n\n\nLa MMU, utilizzando la tabella dei segmenti, traduce il numero del segmento s in un indirizzo fisico di base per quel segmento.\n\n\nPassaggio 2 - Traduzione della pagina:\n\n\nUna volta che il segmento è stato individuato, l’indirizzo logico viene trattato come una pagina all’interno di quel segmento.\n\n\nOgni segmento è suddiviso in pagine, quindi la MMU usa la tabella delle pagine per tradurre il numero della pagina p in un frame fisico.\n\n\nPassaggio 3 - Calcolo dell’indirizzo fisico finale:\n\n\nUna volta che il numero del frame fisico f è stato ottenuto dalla tabella delle pagine, viene sommato allo spiazzamento d per ottenere l’indirizzo fisico finale.\n\n"},"TPI/VM":{"title":"VM","links":["TPI/installazione-VM"],"tags":[],"content":"Macchine Virtuali (VM)\nLe macchine virtuali (VM) sono ambienti software che simulano un computer fisico, permettendo l’esecuzione di diversi sistemi operativi su un’unica macchina hardware. Questa tecnologia si basa su un software chiamato hypervisor, che gestisce le risorse e consente la creazione e l’esecuzione di più VM contemporaneamente.\nVantaggi delle Macchine Virtuali\nLe macchine virtuali offrono numerosi vantaggi, tra cui:\n\n\nIsolamento: Ogni VM opera in un ambiente separato. Ciò significa che un problema in una VM non influisce sulle altre o sul sistema host.\n\n\nEsecuzione di Sistemi Operativi Diversi: Le VM consentono di eseguire diversi sistemi operativi sulla stessa macchina. Questo è particolarmente utile per gli sviluppatori che testano applicazioni su più piattaforme.\n\n\nFacilità di Backup e Ripristino: Le macchine virtuali possono essere facilmente salvate e replicate tramite snapshot, rendendo il backup e il ripristino semplici e veloci.\n\n\nQui potrai trovare un esempio di installazione VM."},"TPI/installazione-VM":{"title":"installazione VM","links":[],"tags":[],"content":"Prerequisiti\n\n\nComputer con Risorse Adeguate: Assicurati che il tuo computer abbia sufficienti risorse hardware (CPU, RAM e spazio su disco) per eseguire una macchina virtuale.\n\n\nDownload di Oracle VirtualBox: Scarica l’ultima versione di Oracle VirtualBox.\n\n\nFile ISO del Sistema Operativo: Assicurati di avere un file ISO del sistema operativo che desideri installare sulla VM. Puoi scaricare distribuzioni Linux gratuitamente o utilizzare un disco di installazione di Windows.\n\n\nGuida per Fedora Server 40\n\n\nScaricare iso di Fedora server.\neffettua il download per Fedora 40 Server DVD iso\n\n\nVerificare l’integrità dell’immagine scaricata con Powershell.\nApri Powershell su Windows e digita: \t  Get-FileHash -Algorithm SHA256 &quot;C:\\percorso\\file.iso&quot;\notterrai un codice HASH\nora dovrai scaricare il checksum sempre dal link precedente e verificare che il codice HASH generato nella powershell sia identico a quello presente nel checksum.\nSe corrisponde significa che l’immagine ISO è integra, in caso contrario è corrotta e dovrai riscaricare l’immagine ISO.\n\n\nPianificare le caratteristiche HW della macchina virtuale (2 * CPU min; 1,5 * RAM min; 2,5 * HDD min).\nin base alle caratteristiche del tuo computer effettua questi calcoli per impostarli di seguito sul VirtualBox.\n\n\nNel VirtualBox vai su archiviazione&gt;clicca sull’icona del disco e seleziona l’immagine ISO che hai scaricato in precedenza.\n\n\nAssicurati che la rete sia abilitata andando nella sezione Rete.\n\n\nClicca su Avvia per avviare la VM.\n\n\ncrea un account con usuername e password appena si è avviata la macchina virtuale e crea delle partizioni(/tmp , /var , /swap) e formattare ogni partizione (se permesso) in BTRFS.\n\n\nDopo aver finito questo processo, clicca su continua e ti troverai in una CLI, dove dovrai eseguire degli aggiornamenti tramite il comando sudo dnf update.\n\n"},"TPI/metadati":{"title":"metadati","links":[],"tags":[],"content":"Cosa Sono i Metadati?\nI metadati sono dati che descrivono le caratteristiche di un file, come il nome, la dimensione, la data di creazione e modifica, i permessi, e così via.\nVisualizzare i Metadati\nPuoi visualizzare i metadati di un file utilizzando il comando ls -l o stat.\nEsempi\n# Visualizza i metadati dettagliati di un file\nls -l nomefile.txt\n \n# Visualizza metadati estesi\nstat nomefile.txt"},"index-2":{"title":"index 2","links":[],"tags":[],"content":"BENVENUTI NEL MIO SITO!"},"index":{"title":"index","links":[],"tags":[],"content":"BENVENUTI NEL MIO SITO!"}}