{"TPI/CLI":{"title":"CLI","links":["TPI/LINUX"],"tags":[],"content":"Introduzione alla Command Line Interface (CLI)\nCLI è un tipo di interfaccia utente caratterizzata da un’interazione testuale tra utente ed elaboratore.\nL’utente impartisce comandi testuali in input mediante tastiera alfanumerica e riceve risposte testuali in output dall’elaboratore mediante display o stampante alfanumerici. Nei sistemi operativi moderni usati nei personal computer, al posto della CLI, in buona parte, c’è l’interfaccia grafica (GUI).\n\nPuoi trovare un elenco di comandi essenziali nel file LINUX.\n\nRisorse Aggiuntive\nPer approfondire ulteriormente, puoi visitare la documentazione ufficiale di Linux su linux.org."},"TPI/CODICE-RILOCABILE":{"title":"CODICE RILOCABILE","links":[],"tags":[],"content":"==Un codice rilocabile è un tipo di codice generato durante la fase di compilazione di un programma==, in cui gli indirizzi delle istruzioni e dei dati non sono definitivi, ma relativi. Ciò significa che, invece di fare riferimento a indirizzi di memoria fissi (assoluti), il codice utilizza indirizzi logici o simbolici che verranno successivamente trasformati in indirizzi fisici durante il caricamento del programma in memoria.\nQuando un programma contenente codice rilocabile viene caricato in memoria, il loader del sistema operativo esegue una rilocazione, cioè modifica gli indirizzi relativi per adattarli alla posizione effettiva del programma in memoria. Questo permette al programma di essere caricato in diverse posizioni fisiche della memoria, rendendolo più flessibile e facilitando la gestione della memoria nei sistemi operativi multitasking.\nIl compilatore genera gli indirizzi ipotizzando che il programma venga caricato nella memoria a partire dalla cella 0 e in base a questo valore vengono generati tutti gli indirizzi e i collegamenti dati/istruzioni. Può avvenire in momenti diversi:\n\nAll’atto del caricamento in memoria (rilocazione statica): viene individuato l’indirizzo iniziale (indirizzo base) e viene sommato a tutti i riferimenti presenti nel programma (offset).\nIn fase di esecuzione del programma (rilocazione dinamica): viene inserito in apposito registro (registro base) il valore dell’indirizzo effettivo della prima locazione di memoria centrale; quindi durante l’esecuzione, istruzione per istruzione, si calcola l’indirizzo fisico sommando a ogni indirizzo relativo il contenuto del registro base.\n"},"TPI/Compilatore":{"title":"Compilatore","links":["TPI/SO"],"tags":[],"content":"Cos’è un Compilatore?\nUn compilatore è un programma che traduce il codice sorgente scritto in un linguaggio di programmazione in un formato eseguibile, generalmente codice macchina. Questo processo di traduzione consente al computer di eseguire le istruzioni scritte dall’utente.\nFunzionamento\nIl processo di compilazione può essere suddiviso in diverse fasi:\n\n\nAnalisi lessicale: Il compilatore legge il codice sorgente e lo divide in unità lessicali, chiamate “token”. Ogni token rappresenta un elemento del linguaggio, come parole chiave, identificatori, operatori e simboli.\n\n\nAnalisi sintattica: Il compilatore verifica la sintassi del codice per assicurarsi che segua le regole grammaticali del linguaggio.\n\n\nAnalisi semantica: Qui, il compilatore controlla il significato del codice, assicurandosi che le operazioni siano appropriate.\n\n\nGenerazione del codice: Infine, il compilatore genera il codice macchina o un file eseguibile che il computer può eseguire direttamente.\n\n\nVantaggi\n1. Velocità di Esecuzione\nIl codice compilato tende a essere più veloce rispetto a quello interpretato, poiché è già stato tradotto in istruzioni di codice macchina.\n2. Controllo degli Errori\nDurante la fase di compilazione, il compilatore rileva e segnala errori di sintassi e semantica prima che il programma venga eseguito, riducendo la probabilità di errori a runtime.\nSvantaggi\n1. Tempo di Compilazione\nLa fase di compilazione può richiedere tempo, specialmente per programmi di grandi dimensioni. Ogni modifica al codice richiede una nuova compilazione.\n2. Debugging Complesso\nGli errori potrebbero non essere evidenti fino a quando il programma non viene eseguito. La ricerca di errori può richiedere più tempo rispetto a un interprete, che fornisce feedback immediato.\n3. Dipendenza dalla Piattaforma\nIl codice compilato è specifico per una piattaforma. Un programma compilato per Windows, ad esempio, potrebbe non funzionare su un SO linux senza una nuova compilazione."},"TPI/INTERPRETE":{"title":"INTERPRETE","links":["TPI/Compilatore"],"tags":[],"content":"Cos’è un interprete?\n\nUn interprete è un tipo di programma software che esegue il codice sorgente scritto in un linguaggio di programmazione, riga per riga. Questo approccio consente agli sviluppatori di ottenere feedback immediato e facilita il processo di debugging.\n\nFunzionamento\nIl funzionamento di un interprete può essere suddiviso in diverse fasi:\n\n\nAnalisi lessicale: L’interprete esamina il codice sorgente e lo scompone in unità lessicali chiamate token. Ogni token rappresenta un elemento del linguaggio, come una parola chiave, un identificatore o un simbolo.\n\n\nAnalisi sintattica: Dopo la fase di analisi lessicale, l’interprete verifica se i token formano una sintassi valida secondo le regole del linguaggio.\n\n\nEsecuzione: Una volta che il codice è stato analizzato e convalidato, l’interprete esegue le istruzioni in tempo reale. Ogni riga di codice viene tradotta e eseguita immediatamente.\n\n\nGestione degli errori: Se l’interprete incontra un errore durante l’esecuzione, si ferma e fornisce un messaggio di errore, consentendo all’utente di correggere il problema.\n\n\nVantaggi\n1. Esecuzione immediata\nUno dei principali vantaggi di un interprete è la possibilità di vedere i risultati immediatamente. Gli sviluppatori possono eseguire parti del codice senza dover compilare l’intero programma.\n2. Facilità di debugging\nIl debugging è semplificato, poiché l’interprete esegue il codice riga per riga. Gli sviluppatori possono identificare rapidamente la riga problematica e apportare modifiche al volo.\n3. Portabilità\nI linguaggi interpretati tendono ad essere più portabili. Poiché il codice sorgente viene eseguito da un interprete specifico per ogni piattaforma, è possibile eseguire lo stesso codice su diverse piattaforme senza modifiche significative.\nSvantaggi\n1. Velocità di esecuzione\nI programmi eseguiti tramite un interprete possono essere più lenti rispetto a quelli compilati. Questo è dovuto al fatto che l’interprete deve tradurre il codice riga per riga.\n2. Dipendenza dal codice sorgente\nPer eseguire un programma, è necessario avere accesso al codice sorgente. Ciò può rendere difficile la distribuzione di software chiuso o commerciale, poiché gli utenti devono avere accesso al codice.\nInterprete vs Compilatore\nÈ importante notare la differenza tra interpreti e compilatori. Mentre gli interpreti eseguono il codice riga per riga, i compilatori traducono l’intero codice sorgente in un file eseguibile prima dell’esecuzione. Questo porta a differenze significative in termini di prestazioni e usabilità.\n\nEsecuzione: Gli interpreti sono più adatti per il testing e lo sviluppo, mentre i compilatori sono preferiti per applicazioni ad alte prestazioni.\nFeedback: Gli interpreti forniscono un feedback immediato, mentre i compilatori richiedono una fase di compilazione prima di poter eseguire il programma.\n"},"TPI/LINUX":{"title":"LINUX","links":["TPI/SO","TPI/CLI","TPI/metadati"],"tags":[],"content":"GUIDA COMANDI\n\nLa shell più comunemente utilizzata per i SO Linux è chiamata shell Bash(CLI).\n\nIl ~ simbolo viene utilizzato come abbreviazione per la directory home dell’utente. \nIn questa guida potrai trovare i comandi fondamentali di Linux con i relativi esempi e spiegazioni di ciò che avviene.\ncomando [opzioni] [argomenti]\n\npwd [OPTIONS]\nIl comando pwd stampa la directory di lavoro, che è la posizione corrente dell’utente all’interno del filesystem.\n\nsysadmin@localhost:~$ pwd\n\n/home/sysadmin\n\n\n\ncd [options] [path]\nPer navigare nel filesystem, usa cd command.\n\nsysadmin@localhost:~$ cd Documents\n\nsysadmin@localhost:~/Documents$\n\n\nIl carattere ~ è equivalente a /home/sysadmin, che rappresenta la directory home dell’utente.\nSe utilizzato senza argomenti, il comando cd porterà l’utente alla propria directory home.\n\nsysadmin@localhost:~/Documents$ cd\n\nsysadmin@localhost:~$\n\n\nPuoi mettere anche un percorso di tipo assoluto utilizzando il comando cd:\n\nsysadmin@localhost:~/Documents$ cd /home/sysadmin/Documents/School/Art\n\nsysadmin@localhost:~/Documents/School/Art$\n\n\nDue caratteri punto .. rappresentano sempre una directory più in alto rispetto alla directory corrente.\n\nsysadmin@localhost:~/Documents/School/Art$ cd ..\n\nsysadmin@localhost:~/Documents/School$\n\n\n\nls [OPTION]… [FILE]…\nQuesto comando ls viene utilizzato per visualizzare il contenuto di una directory e può fornire informazioni dettagliate sui file.\n\nsysadmin@localhost:~$ ls\n\nDesktop Documents Downloads Music Pictures Public\n\n\nIl comando ls può essere utilizzato anche per elencare il contenuto di qualsiasi directory nel filesystem. Fornire il percorso della directory come argomento:\n\nsysadmin@localhost:~$ ls /var\n\nbackups cache lib local lock log mail opt run spool tmp\n\n\nIl comando ls omette i file nascosti per impostazione predefinita. Un file nascosto è qualsiasi file (o directory) che inizia con un punto(.) carattere.\n\nsysadmin@localhost:~$ ls -a\n\n. .bashrc .selected_editor Downloads Public\n\n.. .cache Desktop Music Templates\n\n.bash_logout .profile Documents Pictures Videos\n\n\nA ogni file sono associati dettagli chiamati metadati.\nPer visualizzare queste informazioni, utilizzare ** l’opzione -l** del comando ls.\n\nsysadmin@localhost:~$ ls -l /var/log/\n\ntotal 900\n\n-rw-r--r-- 1 root root 15322 Dec 10 21:33 alternatives.log\n\ndrwxr-xr-x 1 root root 4096 Jul 19 06:52 apt\n\n-rw-r----- 1 syslog adm 371 Dec 15 16:38 auth.log\n\n-rw-r--r-- 1 root root 35330 May 26 2018 bootstrap.log\n\n-rw-rw---- 1 root utmp 0 May 26 2018 btmp\n\n-rw-r----- 1 syslog adm 197 Dec 15 16:38 cron.log\n\n-rw-r--r-- 1 root adm 85083 Dec 10 21:33 dmesg\n\n-rw-r--r-- 1 root root 351960 Jul 19 06:52 dpkg.log\n\n-rw-r--r-- 1 root root 32064 Dec 10 21:33 faillog\n\ndrwxr-xr-x 2 root root 4096 Jul 19 06:51 journal\n\n-rw-rw-r-- 1 root utmp 292584 Dec 15 16:38 lastlog\n\n-rw-r----- 1 syslog adm 14185 Dec 15 16:38 syslog\n\n-rw------- 1 root root 64128 Dec 10 21:33 tallylog\n\n-rw-rw-r-- 1 root utmp 384 Dec 15 16:38 wtmp\n\n\n\nsysadmin@localhost:~$ ls -ld\n\ndrwxr-xr-x 1 sysadmin sysadmin 224 Nov 7 17:07 .\n\n\n\nPer eseguire un elenco ricorsivo, utilizzare l’opzione -R del comando ls:\n\nsysadmin@localhost:~$ ls -R /etc/ppp\n\n/etc/ppp:\n\nip-down.d ip-up.d\n\n  \n\n/etc/ppp/ip-down.d:\n\nbind9\n\n  \n\n/etc/ppp/ip-up.d:\n\nbind9\n\n\n\nPer ordinare i file in base alla dimensione, possiamo utilizzare l’opzione -S.\n\nsysadmin@localhost:~$ ls -S /etc/ssh\n\nmoduli ssh_host_ed25519_key ssh_host_ecdsa_key.pub\n\nsshd_config ssh_host_rsa_key.pub ssh_host_ed25519_key.pub\n\nssh_host_rsa_key ssh_import_id\n\nssh_config ssh_host_ecdsa_key\n\n\nPotrebbe anche essere utile utilizzare l’opzione -h per visualizzare le dimensioni dei file leggibili dall’uomo.\nL’opzione -t ordina i file in base all’ora in cui sono stati modificati."},"TPI/Memoria-virtuale":{"title":"Memoria virtuale","links":[],"tags":[],"content":"La memoria virtuale è una tecnica che permette al computer di usare una parte del disco rigido come estensione della RAM. Quando la RAM è piena, il sistema operativo sposta temporaneamente su disco alcuni dati o processi inattivi (swap out) per fare spazio in RAM per altri programmi attivi. Questo consente di eseguire programmi più grandi della memoria fisica disponibile, dando l’impressione di avere più RAM di quella realmente installata.\nProgram counter cambia:\nIl program counter (PC) è un registro che tiene traccia dell’istruzione successiva da eseguire. Quando avviene uno swap out in memoria virtuale, cioè lo spostamento temporaneo di un processo inattivo sul disco, il sistema deve aggiornare il program counter per ricordare a che punto si trovava l’esecuzione di quel processo.\nQuando il processo viene riportato in RAM per continuare l’esecuzione, il program counter viene ripristinato al valore corretto, consentendo al processo di riprendere dall’istruzione esatta in cui era stato interrotto. Questo aggiornamento è essenziale per mantenere la coerenza dell’esecuzione del programma."},"TPI/PROGRAMMA-e-PROCESSO":{"title":"PROGRAMMA e PROCESSO","links":["TPI/INTERPRETE","TPI/Compilatore"],"tags":[],"content":"Definizioni\nIn parole semplici, un programma per computer è una serie di istruzioni dettagliate che indicano al computer cosa fare.\n==Un programma è costituito dall’insieme delle sue istruzioni memorizzate su una memoria di massa. È una entità statica.==\nPer essere eseguito, un programma deve essere interpretato o compilato. Gli interpreti eseguono il codice riga per riga, mentre i compilatori trasformano tutto il codice in un formato eseguibile in una singola operazione.\n==Processo è un’istanza di un programma in evoluzione, è una entità dinamica utilizza risorse come CPU, memoria e file aperti.\nUn Processo possiede una traccia di esecuzione==(sequenza di stati assunti dal processore durante l’esecuzione del processo).\nA un processo sono associati:\n\n==Codice eseguibile==\nSpazio di memoria con i ==dati== e lo spazio per lo Stack\n==Il PCB(process control Block) o descrittore di processo: struttura apposita che contiene informazioni dello stato del processo,== come: ==PID== ( valore numeri da 1 a 30000) pid =0 indica un processo speciale chiamato swapper, PID =1  appartiene al processo INIT( primo processo creato all’avvio del sistema e rimane in funzione tutto il tempo); ==puntatore==(indirizzo del descrittore del processo che l’ha generato(processo padre)), la priorità, ==stato di avanzamento(contenuto dei registri di lavoro), immagine della memoria==, info relative alle ==altre risorse assegnate al processo==.\n\nProcesso chiamato padre può generare copie di se stesso chiamate processi figli.\n\nProcesso per essere eseguito deve essere allocato in memoria centrale (RAM).\n\nUn processo può essere rimosso dalla memoria e trasferito su disco(swap out) per permettere l’esecuzione di un altro processo che richiede più memoria RAM e in seguito riportarlo in memoria (swap in) per proseguire l’esecuzione.\nSwap Out\n\n\nObiettivo: L’operazione di swap out viene eseguita quando la RAM non ha spazio sufficiente per ospitare tutti i processi attivi. Questo può accadere quando:\n\n\nUn processo in esecuzione richiede più memoria di quanto attualmente disponibile.\n\n\nUn processo (o parte di esso) viene trasferito dallo spazio di memoria RAM allo spazio di swap su disco rigido(hard disk).\n\n\nQuesto libera spazio in RAM, consentendo ad altri processi di essere caricati o continuare la loro esecuzione.\n\n\nSwap In\n\nObiettivo: L’operazione di swap in avviene quando il sistema ha bisogno di accedere nuovamente a un processo che è stato precedentemente swappato nel disco rigido.\nIl sistema operativo recupera il processo dallo spazio di swap su disco e lo carica di nuovo in RAM.\nSe non c’è abbastanza spazio libero in RAM, potrebbe essere necessario swappare un altro processo attualmente in esecuzione per fare spazio per quello che si sta caricando.\n"},"TPI/SO":{"title":"SO","links":[],"tags":[],"content":"Cos’è un Sistema Operativo?\nUn sistema operativo (SO) è un software fondamentale che gestisce le risorse hardware e software di un computer. Funziona come intermediario tra l’utente e l’hardware, consentendo l’esecuzione di programmi e la gestione delle risorse del sistema.\n==Sistemi operativi lavorano in multiprogrammazione==. La multiprogrammazione è una tecnica che permette a un sistema operativo di gestire più programmi in memoria contemporaneamente. In questo modo, quando un processo è in attesa, il sistema operativo può passare a un altro processo che è pronto per essere eseguito. Questo approccio consente di ridurre i tempi di inattività e di migliorare l’utilizzo della CPU.\nFunzioni Principali di un Sistema Operativo\n\n\nGestione delle Risorse Hardware: Il SO controlla e coordina l’uso di CPU, memoria, dischi rigidi e dispositivi di input/output.\n\n\nEsecuzione dei Processi: Gestisce l’esecuzione dei programmi, allocando tempo di CPU e memoria in modo efficiente.\n\n\nGestione della Memoria: Tiene traccia della memoria utilizzata dai processi e gestisce la memoria virtuale.\n\n\nGestione dei File: Fornisce un sistema di file per l’organizzazione, la memorizzazione e l’accesso ai dati.\n\n\nInterfaccia Utente: Fornisce un’interfaccia (grafica o testuale) per consentire agli utenti di interagire con il computer.\n\n\nSistemi Operativi Monoutente e Multiutente\n\nMonoutente: Gestisce un solo utente alla volta (es. MS-DOS).\nMultiutente: Permette a più utenti di utilizzare il sistema contemporaneamente.\n\nSistemi mono-processore e multi-processore\nNel sistema mono-processore c’è un unico processore che può eseguire una sola istruzione alla volta. Tuttavia, per simulare il multitasking, il sistema operativo esegue un’alternanza tra i processi, tramite una tecnica chiamata time slicing.\nOgni processo viene eseguito per una piccola quantità di tempo, chiamata quantum di tempo, prima che il processore passi al processo successivo. Anche se i processi avanzano uno alla volta, l’alternanza è così rapida che l’utente percepisce un’esecuzione simultanea.\nNel sistema multi-processore sono presenti più processori fisici o core che possono eseguire i processi realmente in parallelo. Questo significa che diversi processi o thread possono essere assegnati a processori separati e eseguiti simultaneamente.\nQuesta capacità di eseguire processi parallelamente aumenta la potenza di calcolo e consente un multitasking reale, particolarmente utile per carichi di lavoro intensivi o complessi.\nEsempi di Sistemi Operativi\n\nWindows: Un sistema operativo sviluppato da Microsoft, popolare per computer desktop e laptop.\nmacOS: Sistema operativo sviluppato da Apple per i suoi computer.\nLinux: Un sistema operativo open-source molto usato in server.\nAndroid: Basato su Linux, progettato per dispositivi mobili.\n\nVantaggi dei Sistemi Operativi\n\nFacilità d’uso: Offrono interfacce intuitive per l’interazione con l’hardware.\nGestione Efficiente delle Risorse: Ottimizzano l’uso della CPU, della memoria e delle periferiche.\nSicurezza: Forniscono meccanismi per la protezione dei dati e l’autenticazione degli utenti.\n\nDifetti dei Sistemi Operativi\n\nCosti: Alcuni sistemi operativi commerciali possono avere costi elevati di licenza.\nRisorse: I sistemi operativi più complessi richiedono più risorse hardware.\nVulnerabilità: Possono essere soggetti a malware e attacchi informatici se non gestiti correttamente.\n"},"TPI/VM":{"title":"VM","links":["TPI/installazione-VM"],"tags":[],"content":"Macchine Virtuali (VM)\nLe macchine virtuali (VM) sono ambienti software che simulano un computer fisico, permettendo l’esecuzione di diversi sistemi operativi su un’unica macchina hardware. Questa tecnologia si basa su un software chiamato hypervisor, che gestisce le risorse e consente la creazione e l’esecuzione di più VM contemporaneamente.\nVantaggi delle Macchine Virtuali\nLe macchine virtuali offrono numerosi vantaggi, tra cui:\n\n\nIsolamento: Ogni VM opera in un ambiente separato. Ciò significa che un problema in una VM non influisce sulle altre o sul sistema host.\n\n\nEsecuzione di Sistemi Operativi Diversi: Le VM consentono di eseguire diversi sistemi operativi sulla stessa macchina. Questo è particolarmente utile per gli sviluppatori che testano applicazioni su più piattaforme.\n\n\nFacilità di Backup e Ripristino: Le macchine virtuali possono essere facilmente salvate e replicate tramite snapshot, rendendo il backup e il ripristino semplici e veloci.\n\n\nQui potrai trovare un esempio di installazione VM."},"TPI/installazione-VM":{"title":"installazione VM","links":[],"tags":[],"content":"Prerequisiti\n\n\nComputer con Risorse Adeguate: Assicurati che il tuo computer abbia sufficienti risorse hardware (CPU, RAM e spazio su disco) per eseguire una macchina virtuale.\n\n\nDownload di Oracle VirtualBox: Scarica l’ultima versione di Oracle VirtualBox.\n\n\nFile ISO del Sistema Operativo: Assicurati di avere un file ISO del sistema operativo che desideri installare sulla VM. Puoi scaricare distribuzioni Linux gratuitamente o utilizzare un disco di installazione di Windows.\n\n\nGuida per Fedora Server 40\n\n\nScaricare iso di Fedora server.\neffettua il download per Fedora 40 Server DVD iso\n\n\nVerificare l’integrità dell’immagine scaricata con Powershell.\nApri Powershell su Windows e digita: \t  Get-FileHash -Algorithm SHA256 &quot;C:\\percorso\\file.iso&quot;\notterrai un codice HASH\nora dovrai scaricare il checksum sempre dal link precedente e verificare che il codice HASH generato nella powershell sia identico a quello presente nel checksum.\nSe corrisponde significa che l’immagine ISO è integra, in caso contrario è corrotta e dovrai riscaricare l’immagine ISO.\n\n\nPianificare le caratteristiche HW della macchina virtuale (2 * CPU min; 1,5 * RAM min; 2,5 * HDD min).\nin base alle caratteristiche del tuo computer effettua questi calcoli per impostarli di seguito sul VirtualBox.\n\n\nNel VirtualBox vai su archiviazione&gt;clicca sull’icona del disco e seleziona l’immagine ISO che hai scaricato in precedenza.\n\n\nAssicurati che la rete sia abilitata andando nella sezione Rete.\n\n\nClicca su Avvia per avviare la VM.\n\n\ncrea un account con usuername e password appena si è avviata la macchina virtuale e crea delle partizioni(/tmp , /var , /swap) e formattare ogni partizione (se permesso) in BTRFS.\n\n\nDopo aver finito questo processo, clicca su continua e ti troverai in una CLI, dove dovrai eseguire degli aggiornamenti tramite il comando sudo dnf update.\n\n"},"TPI/metadati":{"title":"metadati","links":[],"tags":[],"content":"Cosa Sono i Metadati?\nI metadati sono dati che descrivono le caratteristiche di un file, come il nome, la dimensione, la data di creazione e modifica, i permessi, e così via.\nVisualizzare i Metadati\nPuoi visualizzare i metadati di un file utilizzando il comando ls -l o stat.\nEsempi\n# Visualizza i metadati dettagliati di un file\nls -l nomefile.txt\n \n# Visualizza metadati estesi\nstat nomefile.txt"},"index":{"title":"index","links":[],"tags":[],"content":"BENVENUTI NEL MIO SITO!"}}